// ==Headers==
// @Name:               comicSort
// @Description:        comicSort
// @Version:            1.0.0
// @Author:             dodying
// @Date:               2017-12-03 08:31:33
// @Last Modified by:   dodying
// @Last Modified time: 2018-02-07 11:17:03
// @Namespace:          https://github.com/dodying/Nodejs
// @SupportURL:         https://github.com/dodying/Nodejs/issues
// @Require:            readline-sync,async,jszip,superagent,image-size,tracer,colors,glob,mkdirp
// ==/Headers==

//设置
const comicFolder = 'F:\\Temp';
const libraryFolder = 'F:\\ComicLibrary';
const subFolder = [
  '0.Series',
  '1.Cosplay',
  '2.Image Set',
  '3.Game CG',
  '4.Doujinshi',
  '5.Harem',
  '6.Incest',
  '7.Story arc',
  '8.Anthology',
  '9.Artist',
  '10.Other'
];

//导入原生模块
const fs = require('fs');
fs.exists = path => {
  try {
    fs.statSync(path);
  } catch (err) {
    return false;
  }
  return true;
}
const path = require('path');

//导入第三方模块
const readlineSync = require('readline-sync');
const async = require('async');
const JSZip = require('jszip');
const superagent = require('superagent');
const sizeOf = require('image-size');
const logger = require('tracer').console({
  format: "{{timestamp}} <{{file}}:L{{line}}:{{pos}}>: {{message}}",
  dateformat: "HH:MM:ss"
});
const colors = require('colors');
colors.setTheme({
  info: 'green',
  help: 'cyan',
  warn: 'yellow',
  debug: 'blue',
  error: 'red'
});
const glob = require('glob');
const mkdirp = require('mkdirp');

const CHS = JSON.parse(fs.readFileSync('data.json', 'utf-8'));

//Function
const escape = text => text.replace(/[\\/:*?"<>|]/g, '-').replace(/\.$/, '');
const parseInfo = text => {
  text = text.replace(/(Page|Image) \d+: .*/g, '').replace(/(Downloaded at|Generated by).*/g, '').replace(/([\r\n]){2,}/g, '\r\n').replace(/[\r\n]+$/g, '').replace(/\r\n> /g, '\r\n');
  let a = text.split(/\r\n/),
    b = {},
    info = {
      title: a[0]
    };
  for (let i of a) {
    if (i.match(/^http/)) {
      info.web = i;
      break;
    }
  }
  for (let i of a) {
    let t = i.split(': ');
    if (t.length > 1) b[t[0]] = t[1];
  }
  if ('parody' in b) info.series = b.parody;
  if (a.indexOf('Uploader Comment:') >= 0) info.summary = a.slice(a.indexOf('Uploader Comment:')).join('\r\n');
  if ('character' in b) info.characters = b.character;
  if ('artist' in b) info.artist = b.artist;
  if ('group' in b) info.group = b.group;
  info.genre = b.Category.match('FREE HENTAI') ? b.Category.match('FREE HENTAI (.*?) GALLERY')[1] : b.Category;
  info.lang = b.Language.match('Chinese') ? 'zh' : b.Language.match('English') ? 'en' : 'ja';
  info.bw = 'misc' in b && b.misc.indexOf('full color') >= 0 ? false : true;
  if ('Rating' in b) info.rate = b.Rating;
  if ('male' in b || 'female' in b || 'misc' in b) info.tags = [].concat(b.male, b.female, b.misc).filter(i => i).join(', ');
  return info;
}
const sortFile = info => {
  if (info.tags && info.tags.match('multi-work series')) {
    return subFolder[0];
  } else if (info.genre.match(/^COSPLAY$/i)) {
    return subFolder[1];
  } else if (info.genre.match(/^(IMAGESET|IMAGE SET)$/i) || (info.tags && info.tags.match('artbook'))) {
    return subFolder[2];
  } else if (info.genre.match(/^(GAMECG|GAME CG SET|ARTISTCG|ARTIST CG SET)$/i)) {
    return subFolder[3];
  } else if (info.genre.match(/^DOUJINSHI$/i) && info.series) {
    if (info.series.match(', ')) {
      return subFolder[4] + '/###Various';
    } else {
      let value = info.series;
      if (value in CHS.parody) value = CHS.parody[value];
      value = escape(value);
      if (info.characters) {
        let value2 = info.characters;
        value2 = value2.match(', ') ? '###Various' : escape(CHS.character[value2] || value2);
        return subFolder[4] + '/' + value + '/' + value2;
      } else {
        return subFolder[4] + '/' + value;
      }
    }
  } else if (info.tags && info.tags.match('harem')) {
    return subFolder[5];
  } else if (info.tags && info.tags.match(/incest|inseki/)) {
    return subFolder[6];
  } else if (info.tags && info.tags.match('story arc')) {
    return subFolder[7];
  } else if ((info.tags && info.tags.match('anthology')) || (info.artist && info.artist.match(', '))) {
    return subFolder[8];
  } else if (info.artist || info.group) {
    let value = (info.artist || info.group);
    if ((value in CHS.artist) || (value in CHS.group)) value = CHS.artist[value] || CHS.group[value];
    return subFolder[9] + '/' + escape(value);
  } else {
    return subFolder[10];
  }
};
const scrapeInfo = url => {
  return new Promise((resolve, reject) => {
    pram = url.split('/');
    superagent.post('https://e-hentai.org/api.php').send({
      method: 'gdata',
      gidlist: [[pram[4] * 1, pram[5]]],
      namespace: 1
    }).set('User-Agent', 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Mobile Safari/537.36').timeout(30 * 1000).end((err, res) => {
      if (err) {
        logger.error(`Request: ${colors.info(url)}\nInfo: `, err);
        reject(err);
      } else {
        let json = JSON.parse(res.text);
        if (!json.gmetadata) {
          reject(new Error('Error post OR not find info'));
          return;
        }
        resolve(json);
      }
    });
  });
}
const moveByInfo = (info, target) => {
  info.file = target;
  let targetNew = sortFile(info);
  targetNew = path.resolve(libraryFolder, targetNew);
  if (!fs.exists(targetNew)) mkdirp.sync(targetNew);
  targetNew = path.resolve(targetNew, escape(info.title) + '.cbz');
  if (targetNew === target) {
    logger.log('文件未移动: ', colors.info(target));
    return;
  }
  if (!fs.exists(targetNew)) {
    fs.renameSync(target, targetNew);
    logger.log(' ==> ', colors.info(targetNew));
  } else {
    let data = fs.readFileSync(targetNew);
    let jszip = new JSZip();
    jszip.loadAsync(data).then(zip => {
      fs.unlinkSync(target);
    }, err => {});
    logger.warn(`目标文件已存在: ${colors.warn(targetNew)} [${colors.warn('如目标文件无错误，将删除原文件')}]`);
  }
}

//Main
if (!fs.exists(libraryFolder)) fs.mkdirSync(libraryFolder);
subFolder.forEach(i => {
  let target = path.resolve(libraryFolder, i);
  if (!fs.exists(target)) fs.mkdirSync(target);
});

let lst = glob.sync(comicFolder + '\\**\\*.@(zip|cbz)');
logger.log('当前任务数: ', colors.info(lst.length));
async.mapSeries(lst, (i, callback) => {
  let target = path.resolve(comicFolder, i);
  logger.log(colors.info(target));
  let data = fs.readFileSync(target);
  let jszip = new JSZip();
  jszip.loadAsync(data).then(zip => {
    let imgs = Object.keys(zip.files).filter(item => item.indexOf('info.txt') < 0 && !item.match(/\/$/));
    let singlePage = 0,
      doublePage = 0,
      smallWidth = 0;
    async.mapSeries(imgs, (j, callback_1) => {
      zip.files[j].async('nodebuffer').then(img => {
        try {
          let size = sizeOf(img);
          if (size.width <= 800) smallWidth++;
          size = size.height / size.width;
          if (size > 1.1) {
            singlePage++;
          } else if (size < 0.9) {
            doublePage++;
          }
        } catch (err) {
          logger.error(err);
        }
        callback_1(null, j);
      }, err => {
        logger.error(err);
      });
    }, (err, result) => {
      if (err) {
        logger.error(err);
        callback_1(null, i);
        return;
      }
      if (singlePage > doublePage && smallWidth < imgs.length * 0.2) {
        logger.warn(colors.warn('图片大小错误，请重新下载: '), target);
        callback(null, i);
        return;
      }
      let infoFile = Object.keys(zip.files).find(item => item.indexOf('info.txt') >= 0);
      zip.files[infoFile].async('text').then(data => {
        let info = parseInfo(data);
        if (!data.match(/Tags:/)) { //如果不存在(v1.23及以前[2016-10-31]下载的文件)
          scrapeInfo(info.web.replace('http://g.e-hentai.org', 'https://e-hentai.org').replace('https://exhentai.org', 'https://e-hentai.org')).then(json => {
            let infoStr = 'Tags:\r\n';
            let tagsList = json.gmetadata[0].tags;
            let tags = {};
            tagsList.forEach(i => {
              let a = i.split(':');
              let key = a.length === 2 ? a[0] : 'misc';
              if (!tags[key]) tags[key] = [];
              tags[key].push(a[1] || a[0]);
            });
            for (let i in tags) {
              infoStr += `> ${i}: ${tags[i].join(', ')}\r\n`;
            }
            data += '\r\n' + infoStr;
            zip.file(infoFile, data).generateAsync({
              type: 'nodebuffer',
              compression: 'DEFLATE',
              compressionOptions: {
                level: 9
              }
            }).then((buffer) => {
              try {
                fs.writeFileSync(target, buffer);
              } catch (err) {
                logger.log(colors.warn(data));
                logger.error('写入压缩错误: ', colors.error(target));
                input = readlineSync.question(colors.warn('你可以尝试手动将以上信息写入info.txt'));
              }
              moveByInfo(info, target);
              callback(null, i);
            }, err => {
              console.log(err);
            });
            let info = parseInfo(data);
          }, err => {
            logger.warn(colors.warn('请求信息失败: ', target, ' ', info.web));
            callback(null, i);
          });
        } else {
          moveByInfo(info, target);
          callback(null, i);
        }
      }, err => {
        logger.error(err);
      });
    });
  }, err => {
    logger.error(err);
  });
}, (err, result) => {
  logger.log(colors.info('任务完成'));
});

// ==Headers==
// @Name:               comicSort
// @Description:        comicSort
// @Version:            1.0.0
// @Author:             dodying
// @Date:               2017-12-03 08:31:33
// @Last Modified by:   dodying
// @Last Modified time: 2018-04-08 20:00:31
// @Namespace:          https://github.com/dodying/Nodejs
// @SupportURL:         https://github.com/dodying/Nodejs/issues
// @Require:            readline-sync,async,jszip,superagent,image-size,tracer,colors,glob,mkdirp,emoji-regex
// ==/Headers==

//设置
const comicFolder = 'F:\\Temp'; //需要整理的文件夹
const libraryFolder = 'F:\\ComicLibrary'; //整理到那个文件夹
const subFolder = [ //子文件夹
  '0.Series',
  '1.Cosplay',
  '2.Image Set',
  '3.Game CG',
  '4.Doujinshi',
  '5.Harem',
  '6.Incest',
  '7.Story arc',
  '8.Anthology',
  '9.Artist',
  '10.Other'
];
const specialFolder = '#Star'; //特殊的子文件夹
const specialRule = JSON.stringify([
  {
    Uploader: 'HUILENDASI',
    folder: '[后宫]鬼畜王汉化组' //不存在该值时, 移动至specialFolder根目录, 否则移动至specialFolder下的该名称文件夹
  },
  {
    artist: 'akatsuki myuuto',
    folder: '[后宫]赤月みゅうと'
  },
  {
    artist: 'mizuryu kei',
    folder: '[乱交]水龍敬'
  }
]);
const jTitle = false; //是否重命名为日本名称

//导入原生模块
const fs = require('fs');
fs.exists = path => {
  try {
    fs.statSync(path);
  } catch (err) {
    return false;
  }
  return true;
}
const path = require('path');

//导入第三方模块
const readlineSync = require('readline-sync');
const async = require('async');
const JSZip = require('jszip');
const superagent = require('superagent');
const sizeOf = require('image-size');
const logger = require('tracer').console({
  format: "{{timestamp}} <{{file}}:L{{line}}:{{pos}}>: {{message}}",
  dateformat: "HH:MM:ss"
});
const colors = require('colors');
colors.setTheme({
  info: 'green',
  help: 'cyan',
  warn: 'yellow',
  debug: 'blue',
  error: 'red'
});
const glob = require('glob');
const mkdirp = require('mkdirp');
const emojiRegex = require('emoji-regex');

const EHT = JSON.parse(fs.readFileSync('EHT.json', 'utf-8')).dataset;

//Function
const escape = text => text.replace(/[\\/:*?"<>|]/g, '-').replace(/\.$/, '');
const parseInfo = text => {
  text = text.replace(/(Page|Image) \d+: .*/g, '').replace(/(Downloaded at|Generated by).*/g, '').replace(/([\r\n]){2,}/g, '\r\n').replace(/[\r\n]+$/g, '').replace(/\r\n> /g, '\r\n');
  let a = text.split(/\r\n/),
    b = {},
    info = {
      title: a[0],
      jTitle: (a[1].match(/^http/)) ? a[0] : a[1]
    };
  for (let i of a) {
    if (i.match(/^http/)) {
      info.web = i;
      break;
    }
  }
  for (let i of a) {
    let t = i.split(': ');
    if (t.length > 1) b[t[0]] = t[1];
  }
  Object.assign(info, b);
  if ('parody' in b) info.series = b.parody;
  if (a.indexOf('Uploader Comment:') >= 0) info.summary = a.slice(a.indexOf('Uploader Comment:')).join('\r\n');
  //if ('character' in b) info.character = b.character;
  //if ('artist' in b) info.artist = b.artist;
  //if ('group' in b) info.group = b.group;
  info.genre = b.Category.match('FREE HENTAI') ? b.Category.match('FREE HENTAI (.*?) GALLERY')[1] : b.Category;
  info.lang = b.Language.match('Chinese') ? 'zh' : b.Language.match('English') ? 'en' : 'ja';
  info.bw = 'misc' in b && b.misc.indexOf('full color') >= 0 ? false : true;
  if ('Rating' in b) info.rating = b.Rating;
  if ('male' in b || 'female' in b || 'misc' in b) info.tags = [].concat(b.male, b.female, b.misc).filter(i => i).join(', ');
  return info;
}
const combineText = (arr, textOnly = undefined) => {
  return arr instanceof Array ? arr.map(i => {
    if (i.type === 0) {
      return i.text;
    } else if (!textOnly && i.type === 2) {
      return `"url("${i.src.replace(/http.?:/g,'')}")"`;
    } else {
      return null;
    }
  }).filter(i => i).join('\\A') : '';
}
const findData = (main, sub, textOnly = undefined) => {
  let data = EHT.filter(i => i.name === main);
  if (data.length === 0 || data[0].tags.length === 0) return {};
  data = data[0].tags.filter(i => i.name === sub.replace(/_/g, ' '));
  if (data.length === 0) return {};
  return {
    name: main === 'misc' ? sub : main + ':' + sub,
    cname: combineText(data[0].cname, textOnly),
    info: combineText(data[0].info, textOnly)
  };
}
const sortFileBySpecialRule = info => {
  let rule = JSON.parse(specialRule);
  for (let i = 0; i < rule.length; i++) {
    let filter = true;
    let folder = rule[i].folder || '';
    delete rule[i].folder;
    for (let j in rule[i]) {
      if (typeof rule[i][j] === 'string') {
        if (rule[i][j] !== info[j]) {
          filter = false;
          break;
        }
      } else if (rule[i][j] instanceof RegExp) {
        if (!rule[i][j].exec(info[j])) {
          filter = false;
          break;
        }
      } else if (rule[i][j] instanceof Function) {
        if (!rule[i][j](info[j])) {
          filter = false;
          break;
        }
      }
    }
    if (filter) return path.resolve(libraryFolder, specialFolder, folder);
  }
  return false;
}
const sortFile = info => {
  if (sortFileBySpecialRule(info)) {
    return sortFileBySpecialRule(info);
  } else if (info.tags && info.tags.match('multi-work series')) {
    return subFolder[0];
  } else if (info.genre.match(/^COSPLAY$/i)) {
    return subFolder[1];
  } else if (info.genre.match(/^(IMAGESET|IMAGE SET)$/i) || (info.tags && info.tags.match('artbook'))) {
    return subFolder[2];
  } else if (info.genre.match(/^(GAMECG|GAME CG SET|ARTISTCG|ARTIST CG SET)$/i)) {
    return subFolder[3];
  } else if (info.genre.match(/^DOUJINSHI$/i) && info.series) {
    if (info.series.match(', ')) {
      return subFolder[4] + '/###Various';
    } else {
      let value = info.series;
      value = findData('parody', value, true).cname || value;
      value = escape(value);
      if (info.character) {
        let value2 = info.character;
        //value2 = value2.match(', ') ? value2.split(', ').map(i => escape(findData('character', i, true).cname || i)).sort().join(', ') : escape(findData('character', value2, true).cname || value2);
        value2 = value2.match(', ') ? '###Various' : escape(findData('character', value2, true).cname || value2);
        return subFolder[4] + '/' + value + '/' + value2;
      } else {
        return subFolder[4] + '/' + value;
      }
    }
  } else if (info.tags && info.tags.match('harem')) {
    return subFolder[5];
  } else if (info.tags && info.tags.match(/incest|inseki/)) {
    return subFolder[6];
  } else if (info.tags && info.tags.match('story arc')) {
    return subFolder[7];
  } else if ((info.tags && info.tags.match('anthology')) || (info.artist && info.artist.match(', '))) {
    return subFolder[8];
  } else if (info.artist || info.group) {
    let value = (info.artist || info.group);
    value = findData('artist', value, true).cname || findData('group', value, true).cname || value;
    value = escape(value);
    return subFolder[9] + '/' + value;
  } else {
    return subFolder[10];
  }
};
const scrapeInfo = url => {
  return new Promise((resolve, reject) => {
    pram = url.split('/');
    superagent.post('https://e-hentai.org/api.php').send({
      method: 'gdata',
      gidlist: [[pram[4] * 1, pram[5]]],
      namespace: 1
    }).set('User-Agent', 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Mobile Safari/537.36').timeout(30 * 1000).end((err, res) => {
      if (err) {
        logger.error(`Request: ${colors.info(url)}\nInfo: `, err);
        reject(err);
      } else {
        let json = JSON.parse(res.text);
        if (!json.gmetadata) {
          reject(new Error('Error post OR not find info'));
          return;
        }
        resolve(json);
      }
    });
  });
}
const moveByInfo = (info, target) => {
  info.file = target;
  let targetFolderNew = sortFile(info).replace(emojiRegex(), '');
  targetFolderNew = path.resolve(libraryFolder, targetFolderNew);
  if (!fs.exists(targetFolderNew)) mkdirp.sync(targetFolderNew);
  let targetNew = path.resolve(targetFolderNew, escape(jTitle ? info.jTitle : info.title) + '.cbz');
  if (targetNew === target) {
    logger.log('文件未移动: ', colors.info(target));
    return;
  }
  if (!fs.exists(targetNew)) {
    fs.renameSync(target, targetNew);
    logger.log(' ==> ', colors.info(targetNew));
  } else {
    let data = fs.readFileSync(targetNew);
    let jszip = new JSZip();
    jszip.loadAsync(data).then(zip => {
      fs.unlinkSync(target);
    }, err => {});
    logger.warn(`目标文件已存在: ${colors.warn(targetNew)} [${colors.warn('如目标文件无错误，将删除原文件')}]`);
  }
}

//Main

let lst = glob.sync(comicFolder + '\\**\\*.@(zip|cbz)');
logger.log('当前任务数: ', colors.info(lst.length));
async.mapSeries(lst, (i, callback) => {
  let target = path.resolve(comicFolder, i);
  logger.log(colors.info(target));
  let data = fs.readFileSync(target);
  let jszip = new JSZip();
  jszip.loadAsync(data).then(zip => {
    if (Object.keys(zip.files).filter(item => item.indexOf('info.txt') >= 0).length === 0) {
      logger.warn(colors.warn('压缩档内不存在info.txt: '), target);
      callback(null, i);
      return;
    }
    let imgs = Object.keys(zip.files).filter(item => item.indexOf('info.txt') < 0 && !item.match(/\/$/));
    let singlePage = 0,
      doublePage = 0,
      smallWidth = 0;
    async.mapSeries(imgs, (j, callback_1) => {
      zip.files[j].async('nodebuffer').then(img => {
        try {
          let size = sizeOf(img);
          if (size.width <= 800) smallWidth++;
          size = size.height / size.width;
          if (size > 1.1) {
            singlePage++;
          } else if (size < 0.9) {
            doublePage++;
          }
        } catch (err) {
          logger.error(err);
        }
        callback_1(null, j);
      }, err => {
        logger.error(err);
      });
    }, (err, result) => {
      if (err) {
        logger.error(err);
        callback_1(null, i);
        return;
      }
      if (singlePage > doublePage && smallWidth < imgs.length * 0.2) {
        logger.warn(colors.warn('图片大小错误，请重新下载: '), target);
        callback(null, i);
        return;
      }
      let infoFile = Object.keys(zip.files).find(item => item.indexOf('info.txt') >= 0);
      zip.files[infoFile].async('text').then(data => {
        let info = parseInfo(data);
        if (!data.match(/Tags:/)) { //如果不存在(v1.23及以前[2016-10-31]下载的文件)
          scrapeInfo(info.web.replace('http://g.e-hentai.org', 'https://e-hentai.org').replace('https://exhentai.org', 'https://e-hentai.org')).then(json => {
            let infoStr = 'Tags:\r\n';
            let tagsList = json.gmetadata[0].tags;
            let tags = {};
            tagsList.forEach(i => {
              let a = i.split(':');
              let key = a.length === 2 ? a[0] : 'misc';
              if (!tags[key]) tags[key] = [];
              tags[key].push(a[1] || a[0]);
            });
            for (let i in tags) {
              infoStr += `> ${i}: ${tags[i].join(', ')}\r\n`;
            }
            data += '\r\n' + infoStr;
            zip.file(infoFile, data).generateAsync({
              type: 'nodebuffer',
              compression: 'DEFLATE',
              compressionOptions: {
                level: 9
              }
            }).then((buffer) => {
              try {
                fs.writeFileSync(target, buffer);
              } catch (err) {
                logger.log(colors.warn(data));
                logger.error('写入压缩错误: ', colors.error(target));
                input = readlineSync.question(colors.warn('你可以尝试手动将以上信息写入info.txt'));
              }
              moveByInfo(info, target);
              callback(null, i);
            }, err => {
              console.log(err);
            });
            let info = parseInfo(data);
          }, err => {
            logger.warn(colors.warn('请求信息失败: ', target, ' ', info.web));
            callback(null, i);
          });
        } else {
          moveByInfo(info, target);
          callback(null, i);
        }
      }, err => {
        logger.error(err);
      });
    });
  }, err => {
    logger.error(err);
  });
}, (err, result) => {
  logger.log(colors.info('任务完成'));
});

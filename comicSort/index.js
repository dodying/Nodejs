// ==Headers==
// @Name:               comicSort
// @Description:        将通过 [E-Hentai Downloader](https://github.com/ccloli/E-Hentai-Downloader) 下载的本子分类
// @Version:            1.0.42
// @Author:             dodying
// @Date:               2019-2-16 15:28:55
// @Namespace:          https://github.com/dodying/Nodejs
// @SupportURL:         https://github.com/dodying/Nodejs/issues
// @Require:            fs-extra,glob,image-size,jszip,puppeteer,request-promise,socks5-https-client
// ==/Headers==

// 设置
const _ = require('./config')
_.introPicName = _.introPicName.map(i => {
  if (i instanceof RegExp && i.source.match(/^\^/)) {
    let source = i.source.replace(/^\^/, '^(|\\d+.)')
    return new RegExp(source, i.flags)
  } else {
    return i
  }
})

// 导入原生模块
const path = require('path')
const cp = require('child_process')

// 导入第三方模块
var puppeteer
try {
  puppeteer = require('puppeteer')
} catch (error) {
  console.log('Cannot find module \'puppeteer\'')
}
const JSZip = require('jszip')
const request = require('request-promise')
const sizeOf = require('image-size')
const glob = require('glob')
const fse = require('fs-extra')
const Agent = require('socks5-https-client/lib/Agent')

const EHT = JSON.parse(fse.readFileSync('EHT.json', 'utf-8')).dataset

let tagFolder
if (_.makeTags) tagFolder = path.resolve(_.libraryFolder, _.subFolderTag)
let req = (url, option = {}) => {
  let requestOption = {
    url: url,
    headers: {
      'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Mobile Safari/537.36'
    },
    timeout: 30 * 1000,
    resolveWithFullResponse: true
  }
  if (_.proxy.match(/^http:/i)) {
    requestOption.proxy = _.proxy
  } else if (_.proxy.match(/^socks5:/i)) {
    requestOption.agentClass = Agent
    let match = _.proxy.match(/^socks5:\/\/([\d.]+):(\w+)/i)
    requestOption.agentOptions = {
      socksHost: match[1],
      socksPort: match[2]
    }
  }
  return request(Object.assign(requestOption, option))
}

// Function
const color = {
  Reset: '\x1b[0m',
  Bright: '\x1b[1m',
  Dim: '\x1b[2m',
  Underscore: '\x1b[4m',
  Blink: '\x1b[5m',
  Reverse: '\x1b[7m',
  Hidden: '\x1b[8m',

  FgBlack: '\x1b[30m',
  FgRed: '\x1b[31m',
  FgGreen: '\x1b[32m',
  FgYellow: '\x1b[33m',
  FgBlue: '\x1b[34m',
  FgMagenta: '\x1b[35m',
  FgCyan: '\x1b[36m',
  FgWhite: '\x1b[37m',

  BgBlack: '\x1b[40m',
  BgRed: '\x1b[41m',
  BgGreen: '\x1b[42m',
  BgYellow: '\x1b[43m',
  BgBlue: '\x1b[44m',
  BgMagenta: '\x1b[45m',
  BgCyan: '\x1b[46m',
  BgWhite: '\x1b[47m'
}
const colors = {
  info: text => color.FgGreen + text + color.Reset,
  help: text => color.FgCyan + text + color.Reset,
  warn: text => color.FgYellow + text + color.Reset,
  debug: text => color.FgBlue + text + color.Reset,
  error: text => color.FgRed + text + color.Reset
}

const symlinkSync = (target, link) => {
  try {
    fse.lstatSync(link)
    fse.unlinkSync(link)
  } catch (error) {
  }
  let parentPath = path.parse(link).dir
  let children = fse.readdirSync(parentPath)
  let rawPath = parentPath
  let order = 1
  while (children.length > 1000) {
    parentPath = rawPath + '-' + order
    if (!fse.existsSync(parentPath)) {
      fse.mkdirsSync(parentPath)
      break
    }
    order++
    children = fse.readdirSync(parentPath)
  }

  fse.symlinkSync(path.relative(parentPath, target), link)
}
const moveFile = (oldpath, newpath, date = undefined) => {
  let info = date && (date instanceof Date || !isNaN(Number(date))) ? { atime: date, mtime: date } : fse.statSync(oldpath)
  try {
    if (path.relative(oldpath, newpath) === '') {

    } else if (path.parse(oldpath).root === path.parse(newpath).root) {
      fse.renameSync(oldpath, newpath)
    } else {
      fse.writeFileSync(newpath, fse.readFileSync(oldpath))
      fse.unlinkSync(oldpath)
    }
    fse.utimesSync(newpath, info.atime, info.mtime)
  } catch (error) {
    if (error.code === 'EBUSY') {
      console.error(colors.error('File Locked: ') + oldpath)
    } else {
      console.error(error)
    }
  }
}
const unique = arr => [...(new Set(arr))]
const escape = text => text.replace(/[\\/:*?"<>|]/g, '-').replace(/\.$/, '').replace(_.emojiRegExp, '')
const escape2 = text => text.replace(/[:*?"<>|]/g, '-').replace(/\.$/, '').replace(_.emojiRegExp, '')
const parseInfo = text => {
  text = text.replace(/(Downloaded at|Generated by).*/g, '').replace(/([\r\n]){2,}/g, '\r\n').replace(/[\r\n]+$/g, '').replace(/\r\n> /g, '\r\n')
  let a = text.split(/\r\n/)
  let b = {}
  let info = {
    title: a[0],
    jTitle: (a[1].match(/^http/)) ? a[0] : a[1],
    page: []
  }
  let tags = ['language', 'reclass', 'artist', 'group', 'parody', 'character', 'female', 'male', 'misc']
  for (let i of a) {
    if (i.match(/^http/)) {
      info.web = i
      break
    }
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i].match(/^Page \d+:/)) {
      let re = a[i].match(/^Page (\d+):\s+(.*)$/)
      info.page[re[1] * 1] = {
        url: re[2],
        id: re[2].split('/')[4]
      }
      a.splice(i, 1)
      i--
    } else if (a[i].match(/^Image \d+:/)) {
      let re = a[i].match(/^Image (\d+):\s+(.*)$/)
      info.page[re[1] * 1].name = re[2]
      a.splice(i, 1)
      i--
    }
  }
  for (let i of a) {
    let t = i.split(': ')
    if (t.length > 1) {
      b[t[0]] = tags.includes(t[0]) ? t[1].split(', ').sort() : t[1]
    }
  }

  if ('parody' in b && b['parody'].length === 1 && b['parody'].includes('original')) delete b['parody']

  Object.assign(info, b)
  if ('parody' in b) info.series = b.parody
  if ('Length' in b) info.length = b.Length.match(/^\d+/)[0]
  if (a.indexOf('Uploader Comment:') >= 0) info.summary = a.slice(a.indexOf('Uploader Comment:')).join('\r\n')
  info.genre = b.Category.match('FREE HENTAI') ? b.Category.match('FREE HENTAI (.*?) GALLERY')[1] : b.Category
  info.lang = b.Language.match('Chinese') ? 'zh' : b.Language.match('English') ? 'en' : 'ja'
  info.bw = !('misc' in b && b.misc.indexOf('full color') >= 0)
  if ('Rating' in b) info.rating = b.Rating
  info.tags = [].concat(b.male, b.female, b.misc).filter(i => i).sort()
  return info
}
const combineText = (arr, textOnly = true) => {
  return arr instanceof Array ? arr.map(i => {
    if (i.type === 0) {
      return i.text
    } else if (!textOnly && i.type === 2) {
      return `"url("${i.src.replace(/http.?:/g, '')}")"`
    } else {
      return null
    }
  }).filter(i => i).join('\\A') : ''
}
const findData = (main, sub = undefined, textOnly = true) => {
  let data = EHT.filter(i => i.name === main)
  if (data.length === 0 || data[0].tags.length === 0) return {}
  if (sub === undefined) {
    return {
      name: main,
      cname: combineText(data[0].cname, textOnly),
      info: combineText(data[0].info, textOnly)
    }
  }
  let data1 = data[0].tags.filter(i => i.name === sub.replace(/_/g, ' '))
  if (data1.length === 0) {
    if (sub.match(' \\| ')) {
      let arr = sub.split(' | ').map(i => i.replace(/_/g, ' '))
      data1 = data[0].tags.filter(i => arr.includes(i.name))
    }
  }
  return data1.length ? {
    name: main === 'misc' ? sub : main + ':' + sub,
    cname: combineText(data1[0].cname, textOnly),
    info: combineText(data1[0].info, textOnly)
  } : {}
}
const sortFileBySpecialRule = info => {
  let rule = _.specialRule
  for (let i = 0; i < rule.length; i++) {
    let folder = rule[i].folder || ''
    let mode = rule[i].mode || 0
    let filter
    if (mode === 0) {
      filter = false
      for (let j in rule[i]) {
        if (['mode', 'folder'].includes(j)) continue
        if (typeof info[j] === 'undefined') break
        let _rule = rule[i][j]
        let _info = [].concat(info[j])
        if (typeof _rule === 'string') {
          if (_info.some(k => k.match('|'))) {
            let _info2 = []
            _info.forEach(k => {
              _info2 = _info2.concat(k.split('|'))
            })
            _info2 = _info2.map(k => k.trim())
            if (_info2.includes(_rule)) {
              filter = true
              break
            }
          }
          if (_info.includes(_rule)) {
            filter = true
            break
          }
        } else if (_rule instanceof RegExp) {
          if (_rule.exec(_info.join(', '))) {
            filter = true
            break
          }
        } else if (_rule instanceof Function) {
          if (_rule(_info)) {
            filter = true
            break
          }
        }
      }
    } else if (mode === 1) {
      filter = true
      for (let j in rule[i]) {
        if (['mode', 'folder'].includes(j)) continue
        if (typeof info[j] === 'undefined') {
          filter = false
          break
        }
        let _rule = rule[i][j]
        let _info = [].concat(info[j])
        if (typeof _rule === 'string') {
          if (_info.some(k => k.match('|'))) {
            let _info2 = []
            _info.forEach(k => {
              _info2 = _info2.concat(k.split('|'))
            })
            _info2 = _info2.map(k => k.trim())
            if (!_info2.includes(_rule)) {
              filter = false
              break
            }
            continue
          }
          if (!_info.includes(_rule)) {
            filter = false
            break
          }
        } else if (_rule instanceof RegExp) {
          if (!_rule.exec(_info.join(', '))) {
            filter = false
            break
          }
        } else if (_rule instanceof Function) {
          if (!_rule(_info)) {
            filter = false
            break
          }
        }
      }
    }
    if (filter) return path.resolve(_.libraryFolder, _.specialFolder, escape2(folder))
  }
  return false
}
const sortFile = info => {
  if (sortFileBySpecialRule(info)) {
    return sortFileBySpecialRule(info)
  } else if (info.tags.includes('multi-work series')) {
    if (info.artist || info.group) {
      let value = [].concat(info.artist, info.group).filter(i => i)[0]
      value = findData('artist', value).cname || findData('group', value).cname || value
      value = escape(value)
      return _.subFolder[0] + '/' + value
    } else {
      return _.subFolder[0]
    }
  } else if (info.genre.match(/^COSPLAY$/i)) {
    return _.subFolder[1]
  } else if (info.genre.match(/^(IMAGESET|IMAGE SET)$/i) || (info.tags.includes('artbook'))) {
    return _.subFolder[2]
  } else if (info.genre.match(/^(GAMECG|GAME CG SET|ARTISTCG|ARTIST CG SET)$/i)) {
    return _.subFolder[3]
  } else if (info.genre.match(/^DOUJINSHI$/i) && info.parody) {
    let parody = info.parody.map(i => {
      let j
      for (j = 0; j < _.parody.length; j++) {
        if (i.match(_.parody[j].filter)) break
      }
      return j < _.parody.length ? _.parody[j].name : i
    })
    parody = unique(parody)
    if (parody.length > 1) {
      return _.subFolder[4] + '/' + escape(parody.map(i => findData('parody', i).cname || i).sort().join(', '))
      // return _.subFolder[4] + '/Various'
    } else {
      let value = parody[0]
      value = escape(findData('parody', value).cname || value)
      if (info.character) {
        let character = info.character.filter(i => !(_.removeCharacter.includes(i)))
        let name = character.length >= 4 ? '###' + character.length : escape(character.map(i => findData('character', i).cname || i).sort().join(', '))
        return _.subFolder[4] + '/' + value + '/' + name
      } else {
        return _.subFolder[4] + '/' + value
      }
    }
  } else if ('female' in info && info.female.includes('harem')) {
    return _.subFolder[5]
  } else if (info.tags.includes('incest') || info.tags.includes('inseki')) {
    let tags = []
    for (let i in _.incestTags) {
      if (info.tags.some(tag => _.incestTags[i].includes(tag))) tags.push(i)
    }
    return _.subFolder[6] + (tags.length ? '/' + tags.sort().join(', ') : '')
  } else if (info.tags.includes('story arc')) {
    return _.subFolder[7]
  } else if ((info.tags.includes('anthology')) || (info.artist && info.artist.length > 2)) {
    return _.subFolder[8]
  } else if (info.artist || info.group) {
    let value = [].concat(info.artist, info.group).filter(i => i)[0]
    value = findData('artist', value).cname || findData('group', value).cname || value
    value = escape(value)
    return _.subFolder[9] + '/' + value
  } else {
    return _.subFolder[10]
  }
}
const moveByInfo = (info, target) => {
  info.file = target

  let targetFolderNew
  if (_.moveFile) {
    targetFolderNew = sortFile(info)
    targetFolderNew = path.resolve(_.libraryFolder, targetFolderNew)
    if (!fse.existsSync(targetFolderNew)) fse.mkdirsSync(targetFolderNew)
  } else {
    targetFolderNew = path.parse(target).dir
  }

  let nameNew = escape(_.jTitle ? info.jTitle : info.title)

  let targetNew = path.resolve(targetFolderNew, nameNew + '.cbz')

  if (targetNew.length >= 250) { // 文件名 > 250
    let sub = targetNew.length - 250
    nameNew = nameNew.substr(0, nameNew.length - sub)
    targetNew = path.resolve(targetFolderNew, nameNew + '.cbz')
  }

  let createSymlinkByInfo = (nameNew) => {
    for (let main in info) {
      let data = EHT.filter(i => i.name === main)
      if (data.length === 0) continue
      for (let sub of info[main]) {
        let text = `${main}: ${sub}`
        if (_.makeTags.some(i => text.match(i))) {
          let folder = path.resolve(tagFolder, findData(main).cname || main, escape(findData(main, sub).cname || sub))
          if (!fse.existsSync(folder)) fse.mkdirsSync(folder)
          symlinkSync(path.resolve(targetFolderNew, nameNew), path.resolve(folder, nameNew))
        }
      }
    }
  }

  let targetShort = path.relative(_.libraryFolder, targetFolderNew)
  let atime
  if (_.cover) {
    let targetCover = path.resolve(_.comicFolder, path.parse(target).name + '.jpg')
    let targetCoverNew = path.resolve(targetFolderNew, nameNew + '.jpg')
    if (fse.existsSync(targetCover)) {
      atime = fse.statSync(targetCover).atime
      if (_.makeTags.length) createSymlinkByInfo(nameNew + '.jpg')
      moveFile(targetCover, targetCoverNew)
    }
  }

  if (_.makeTags.length) createSymlinkByInfo(nameNew + '.cbz')
  moveFile(target, targetNew, atime)

  console.log(' ==> ', colors.info(targetShort))
}
function waitInMs (time) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve()
    }, time)
  })
}

// Main
const main = async () => {
  let lst
  let browser
  let defaultPage

  // 读取列表
  let task = async () => {
    let d = new Date()
    d = d.toLocaleString('zh-CN', {
      hour12: false
    })
    process.title = d
    lst = glob.sync((_.globRecursive ? '**/' : '') + '*.@(zip|cbz)', {
      cwd: _.comicFolder.replace(/\\/g, '/'),
      ignore: [ '**/' + _.subFolderTag + '/**/*', '**/' + _.subFolderDelete + '/**/*' ]
    }).reverse()
    if (lst.length) console.log('当前任务数: ', colors.info(lst.length))

    // 开始处理
    for (let i of lst) {
      let error = await (async () => {
        let index = lst.indexOf(i)
        process.title = index + ': ' + i
        console.log(colors.info(process.title))

        // 处理路径
        let target = path.resolve(_.comicFolder, i)
        let targetDir = path.parse(target).dir

        // 读取数据
        let targetData = fse.readFileSync(target)
        let jszip = new JSZip()
        let zip
        try {
          zip = await jszip.loadAsync(targetData)
        } catch (error) {
          if (error.message === 'End of data reached (data length = 0, asked index = 4). Corrupted zip ?') {
            moveFile(target, path.resolve(_.libraryFolder, _.subFolderDelete, path.parse(target).base))
            console.log(' ==> ', _.subFolderDelete)
            return
          } else {
            console.error(error)
            return error
          }
        }

        // 查看列表
        let fileList = Object.keys(zip.files)

        // 检测有无info.txt
        if (fileList.filter(item => item.match(/(^|\/)info\.txt$/)).length === 0) {
          console.warn(colors.warn('压缩档内不存在info.txt: '), target)
          return
        }

        // 读取info.txt
        let infoFile = fileList.find(item => item.match(/(^|\/)info\.txt$/))
        let data = await zip.files[infoFile].async('text')
        let info = parseInfo(data)

        // 检测图片及大小
        if ((_.delIntroPic || _.checkImageSize) && info.web.match(/e(-|x)hentai.org/)) {
          let imgs = fileList.filter(item => item.match(/\.(jpg|png|gif)$/))
          for (let j = 1; j < imgs.length; j++) { // 跳过封面
            let deleted = false
            if (_.delIntroPic) {
              let name = path.parse(imgs[j]).base
              let filter = info.page.filter(p => p.name === name)
              if ((filter.length && _.introPic.includes(filter[0].id)) || _.introPicName.some(k => name.match(k))) {
                console.log(colors.error('Deleted: '), colors.info(imgs[j]))
                try {
                  cp.execSync(`${_['7z']} d -tzip -mx9 "${target}" "${imgs[j]}"`, {
                    cwd: targetDir
                  })
                } catch (error) {
                  console.error(colors.error('Delete error, skipped this comic pack'))
                  return
                }
                deleted = true
              }
            }
            if (_.checkImageSize && !info.tags.includes('tankoubon') && !info.tags.includes('anthology') && !deleted) {
              let img = await zip.files[imgs[j]].async('nodebuffer')
              let size
              try {
                size = sizeOf(img)
              } catch (error) {
                continue
              }
              let rate = size.width / size.height
              if (rate > _.rate && size.width === _.size) {
                if (!browser) {
                  browser = await puppeteer.launch({
                    headless: false,
                    userDataDir: `${__dirname}\\User Data`,
                    defaultViewport: null,
                    timeout: 0,
                    args: [
                      `--disable-extensions-except=${__dirname}\\Extensions\\Proxy-SwitchyOmega`
                    ]
                  })
                  browser.on('disconnected', () => {
                    process.exit()
                  })
                  defaultPage = (await browser.pages())[0]
                }

                console.log('Size:', colors.info(size.width, '*', size.height), '  Pages:', colors.info(info.length), '  Genre:', colors.info(info.genre))
                console.log('Page', j, ':', colors.warn(imgs[j]))
                let web = info.web.replace('http:', 'https:').replace(/(g.|)e-hentai/, 'exhentai').replace(/#\d+$/, '')
                console.info(colors.info(web))

                let page
                let result = await new Promise(async (resolve, reject) => {
                  page = await browser.newPage()
                  await defaultPage.bringToFront()
                  page.on('load', async () => {
                    let url = await page.url()
                    await page.close()
                    console.log(url, web)
                    if (url !== web) {
                      resolve(true)
                    } else {
                      let file = fse.createWriteStream('list.txt', {
                        flags: 'a'
                      })
                      file.write(url)
                      file.write('\n')
                      file.end()
                      resolve()
                    }
                  })
                  await page.goto(web)
                })
                if (result === undefined) {
                  fse.unlinkSync(target)
                  return
                } else {
                  let file = fse.createWriteStream('error.txt', {
                    flags: 'a'
                  })
                  file.write(web)
                  file.write('\n')
                  file.end()
                  return
                }
              }
            }
          }
        }

        // 解压封面
        if (_.cover) {
          let img = data.match(/Image\s+1:\s+(.*)/)
          let firstImg
          if (img && fileList.find(item => item.match(new RegExp(img[1])))) {
            firstImg = fileList.find(item => item.match(new RegExp(img[1])))
          } else {
            firstImg = fileList.find(item => item.match(/\.(jpg|png|gif)$/))
          }
          let u8a = await zip.files[firstImg].async('uint8array')
          let targetCover = path.resolve(_.comicFolder, path.parse(target).name + '.jpg')
          fse.writeFileSync(targetCover, u8a)
          // 设置最后修改时间
          let date = zip.files[firstImg].date
          fse.utimesSync(targetCover, date, date)
        }

        // 如果info不存在tags(EHD v1.23之前下载的)
        if (!data.match(/Tags:/) && info.web.match(/e(-|x)hentai.org/)) {
          let url = info.web.replace(/^.*hentai.org/, 'https://e-hentai.org')
          let pram = url.split('/')
          let res = await req('https://e-hentai.org/api.php', {
            method: 'POST',
            body: JSON.stringify({
              method: 'gdata',
              gidlist: [[pram[4] * 1, pram[5]]],
              namespace: 1
            })
          })
          let json = JSON.parse(res.body)
          let infoStr = '\r\nTags:\r\n'
          let tagsList = json.gmetadata[0].tags
          let tags = {}
          tagsList.forEach(i => {
            let a = i.split(':')
            let key = a.length === 2 ? a[0] : 'misc'
            if (!tags[key]) tags[key] = []
            tags[key].push(a[1] || a[0])
          })
          for (let i in tags) {
            infoStr += `> ${i}: ${tags[i].join(', ')}\r\n`
          }
          data += '\r\n' + infoStr

          let infoFileDir = path.resolve(targetDir, path.parse(infoFile).dir)
          fse.mkdirsSync(infoFileDir)
          let infoFilePath = path.resolve(infoFileDir, 'info.txt')
          fse.writeFileSync(infoFilePath, data)

          cp.execSync(`${_['7z']} a -tzip -mx9 "${target}" "${infoFile}"`, {
            cwd: targetDir
          })

          fse.unlinkSync(infoFilePath)
          fse.removeSync(infoFileDir)
        }

        // 整理
        moveByInfo(info, target)
      })()
      if (error) throw error
    }

    if (lst.length) console.log(colors.info('任务完成'))
    if (browser) await browser.close()
    browser = null
    if (_.loop) {
      await waitInMs(5 * 1000)
      await task()
    }
  }

  await task()
}

main().then(async () => {
  //
}, async err => {
  console.error(err)
  process.exit()
})
